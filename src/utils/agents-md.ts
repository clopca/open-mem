// =============================================================================
// open-mem ‚Äî Folder-Level AGENTS.md Context Generation
// =============================================================================

import { existsSync } from "node:fs";
import { mkdir, readFile, rename, unlink, writeFile } from "node:fs/promises";
import { dirname, isAbsolute, join, normalize, relative, resolve, sep } from "node:path";
import type { Observation, ObservationType } from "../types";

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const START_TAG = "<!-- open-mem-context -->";
const END_TAG = "<!-- /open-mem-context -->";

const TYPE_ICONS: Record<ObservationType, string> = {
	bugfix: "üî¥",
	feature: "üü£",
	refactor: "üîÑ",
	change: "‚úÖ",
	discovery: "üîµ",
	decision: "‚öñÔ∏è",
};

/** Per-folder lock to serialize concurrent writes and prevent ENOENT race conditions */
const folderLocks = new Map<string, Promise<void>>();

/** Directories that should never get AGENTS.md files */
const EXCLUDED_DIRS = new Set([
	"node_modules",
	".git",
	"dist",
	"coverage",
	".open-mem",
	"build",
	"__pycache__",
	".next",
	".nuxt",
]);

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------

/**
 * Update AGENTS.md files for folders referenced by observations.
 *
 * Groups observations by the folders their files belong to, generates
 * a context block for each folder, and writes it into the managed
 * section of each folder's AGENTS.md.
 *
 * @param projectPath - Absolute path to the project root
 * @param observations - Observations from the current session
 * @param maxDepth - Maximum folder depth from project root (default: 5)
 */
export async function updateFolderContext(
	projectPath: string,
	observations: Observation[],
	maxDepth = 5,
): Promise<void> {
	if (observations.length === 0) return;

	// Collect all file paths from observations
	const allFiles: string[] = [];
	for (const obs of observations) {
		for (const f of obs.filesModified) allFiles.push(f);
		for (const f of obs.filesRead) allFiles.push(f);
	}

	// Extract unique folder paths, filtering out invalid ones
	const folderPaths = extractFolderPaths(allFiles, projectPath, maxDepth);
	if (folderPaths.size === 0) return;

	// Group observations by folder
	const folderObservations = groupObservationsByFolder(observations, folderPaths, projectPath);

	// Update AGENTS.md for each folder
	for (const [folderPath, folderObs] of folderObservations) {
		try {
			const contextBlock = generateFolderContext(folderPath, folderObs, projectPath);
			await updateAgentsMd(folderPath, contextBlock);
		} catch (error) {
			// Fire-and-forget: never let AGENTS.md updates break anything
			console.error(`[open-mem] Failed to update AGENTS.md in ${folderPath}:`, error);
		}
	}
}

// -----------------------------------------------------------------------------
// Context Generation
// -----------------------------------------------------------------------------

/**
 * Generate a markdown context block for a folder's recent activity.
 *
 * @param folderPath - Absolute path to the folder
 * @param observations - Observations relevant to this folder
 * @param projectPath - Absolute path to the project root
 * @returns Markdown string for the managed section
 */
export function generateFolderContext(
	folderPath: string,
	observations: Observation[],
	projectPath: string,
): string {
	// Limit to most recent 10 observations
	const recent = [...observations]
		.sort((a, b) => b.createdAt.localeCompare(a.createdAt))
		.slice(0, 10);

	const relFolder = relative(projectPath, folderPath) || ".";
	const lines: string[] = [];

	lines.push(`## Recent Activity in \`${relFolder}/\` (auto-generated by open-mem)`);
	lines.push("");
	lines.push("| Type | Title | Date |");
	lines.push("|------|-------|------|");

	for (const obs of recent) {
		const icon = TYPE_ICONS[obs.type] || "üìù";
		const date = obs.createdAt.split("T")[0];
		// Escape pipe characters in title
		const safeTitle = obs.title.replace(/\|/g, "\\|");
		lines.push(`| ${icon} ${obs.type} | ${safeTitle} | ${date} |`);
	}

	// Collect unique concepts
	const allConcepts = new Set<string>();
	for (const obs of recent) {
		for (const c of obs.concepts) {
			allConcepts.add(c);
		}
	}

	if (allConcepts.size > 0) {
		const conceptList = [...allConcepts].slice(0, 10).join(", ");
		lines.push("");
		lines.push(`**Key concepts:** ${conceptList}`);
	}

	// Collect decision summaries
	const decisions = recent.filter((obs) => obs.type === "decision").map((obs) => obs.title);

	if (decisions.length > 0) {
		lines.push("");
		lines.push(`**Recent decisions:** ${decisions.slice(0, 5).join("; ")}`);
	}

	return lines.join("\n");
}

// -----------------------------------------------------------------------------
// AGENTS.md File Management
// -----------------------------------------------------------------------------

/**
 * Update the managed section of an AGENTS.md file in the given folder.
 *
 * - Reads existing AGENTS.md if present
 * - Replaces content between managed tags (or appends if no tags exist)
 * - Preserves user content outside the tags
 * - Writes atomically via temp file + rename
 *
 * @param folderPath - Absolute path to the folder (must exist)
 * @param contextBlock - New content for the managed section
 */
export async function updateAgentsMd(folderPath: string, contextBlock: string): Promise<void> {
	if (!existsSync(folderPath)) return;

	// Serialize concurrent writes to the same folder
	const previousLock = folderLocks.get(folderPath) ?? Promise.resolve();
	const currentOp = previousLock.then(async () => {
		const agentsMdPath = join(folderPath, "AGENTS.md");
		const tempPath = join(folderPath, ".AGENTS.md.tmp");

		let existingContent = "";
		try {
			existingContent = await readFile(agentsMdPath, "utf-8");
		} catch {
			// File doesn't exist yet
		}

		const finalContent = replaceTaggedContent(existingContent, contextBlock);

		try {
			await mkdir(dirname(tempPath), { recursive: true });
			await writeFile(tempPath, finalContent, "utf-8");
			await rename(tempPath, agentsMdPath);
		} catch (error) {
			try {
				await unlink(tempPath);
			} catch {
				// Temp file already gone
			}
			throw error;
		}
	});

	folderLocks.set(folderPath, currentOp.catch(() => {}));
	return currentOp;
}

/**
 * Replace content between managed tags, preserving everything else.
 *
 * Three cases:
 * 1. No existing content ‚Üí wrap new content in tags
 * 2. Has existing tags ‚Üí replace only tagged section
 * 3. No tags in existing content ‚Üí append tagged content at end
 */
export function replaceTaggedContent(existingContent: string, newContent: string): string {
	// Case 1: No existing content
	if (!existingContent) {
		return `${START_TAG}\n${newContent}\n${END_TAG}\n`;
	}

	const startIdx = existingContent.indexOf(START_TAG);
	const endIdx = existingContent.indexOf(END_TAG);

	// Case 2: Has existing tags ‚Äî replace only tagged section
	if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
		const before = existingContent.substring(0, startIdx);
		const after = existingContent.substring(endIdx + END_TAG.length);
		return `${before}${START_TAG}\n${newContent}\n${END_TAG}${after}`;
	}

	// Case 3: No tags ‚Äî append at end
	return `${existingContent}\n\n${START_TAG}\n${newContent}\n${END_TAG}\n`;
}

// -----------------------------------------------------------------------------
// Path Helpers
// -----------------------------------------------------------------------------

/**
 * Extract unique, valid folder paths from file paths.
 *
 * Filters out:
 * - Project root itself
 * - Excluded directories (node_modules, .git, etc.)
 * - Folders deeper than maxDepth
 * - Non-existent folders
 * - Paths outside the project
 */
function extractFolderPaths(
	filePaths: string[],
	projectPath: string,
	maxDepth: number,
): Set<string> {
	const folders = new Set<string>();
	const normalizedRoot = resolve(projectPath);

	for (const filePath of filePaths) {
		if (!filePath || !filePath.trim()) continue;

		// Reject URLs and tilde paths
		if (filePath.startsWith("~") || filePath.startsWith("http")) continue;

		// Resolve to absolute path
		const absolutePath = isAbsolute(filePath) ? filePath : join(projectPath, filePath);
		const folderPath = dirname(absolutePath);
		const normalizedFolder = resolve(folderPath);

		// Must be within project
		if (!normalizedFolder.startsWith(normalizedRoot + sep) && normalizedFolder !== normalizedRoot) {
			continue;
		}

		// Skip project root
		if (normalizedFolder === normalizedRoot) continue;

		// Check depth
		const relPath = relative(normalizedRoot, normalizedFolder);
		const depth = relPath.split(sep).length;
		if (depth > maxDepth) continue;

		// Check for excluded directory segments
		const segments = normalize(relPath).split(sep);
		if (segments.some((s) => EXCLUDED_DIRS.has(s))) continue;

		// Must exist on disk
		if (!existsSync(normalizedFolder)) continue;

		folders.add(normalizedFolder);
	}

	return folders;
}

/**
 * Group observations by which folders they reference.
 * An observation can appear in multiple folders if it references files in different directories.
 */
function groupObservationsByFolder(
	observations: Observation[],
	folderPaths: Set<string>,
	projectPath: string,
): Map<string, Observation[]> {
	const groups = new Map<string, Observation[]>();

	for (const obs of observations) {
		const obsFiles = [...obs.filesModified, ...obs.filesRead];
		const obsFolders = new Set<string>();

		for (const filePath of obsFiles) {
			if (!filePath) continue;
			const absolutePath = isAbsolute(filePath) ? filePath : join(projectPath, filePath);
			const folderPath = resolve(dirname(absolutePath));

			if (folderPaths.has(folderPath)) {
				obsFolders.add(folderPath);
			}
		}

		for (const folder of obsFolders) {
			const list = groups.get(folder) ?? [];
			list.push(obs);
			groups.set(folder, list);
		}
	}

	return groups;
}
