// =============================================================================
// open-mem ‚Äî Folder-Level AGENTS.md Context Generation
// =============================================================================

import { existsSync } from "node:fs";
import { mkdir, readFile, rename, unlink, writeFile } from "node:fs/promises";
import { dirname, isAbsolute, join, normalize, relative, resolve, sep } from "node:path";
import type { Observation, ObservationType } from "../types";

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const START_TAG = "<!-- open-mem-context -->";
const END_TAG = "<!-- /open-mem-context -->";

const TYPE_ICONS: Record<ObservationType, string> = {
	bugfix: "üî¥",
	feature: "üü£",
	refactor: "üîÑ",
	change: "‚úÖ",
	discovery: "üîµ",
	decision: "‚öñÔ∏è",
};

/** Per-folder lock to serialize concurrent writes and prevent ENOENT race conditions */
const folderLocks = new Map<string, Promise<void>>();

/** Directories that should never get AGENTS.md files */
const EXCLUDED_DIRS = new Set([
	"node_modules",
	".git",
	"dist",
	"coverage",
	".open-mem",
	"build",
	"__pycache__",
	".next",
	".nuxt",
]);

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------

export interface FolderContextOptions {
	mode: "dispersed" | "single";
	filename: string;
	maxDepth: number;
}

/**
 * Update AGENTS.md files for folders referenced by observations.
 *
 * Groups observations by the folders their files belong to, generates
 * a context block for each folder, and writes it into the managed
 * section of each folder's AGENTS.md.
 *
 * @param projectPath - Absolute path to the project root
 * @param observations - Observations from the current session
 * @param options - Configuration options (mode, filename, maxDepth)
 */
export async function updateFolderContext(
	projectPath: string,
	observations: Observation[],
	options: FolderContextOptions,
): Promise<void> {
	if (observations.length === 0) return;

	if (options.mode === "single") {
		return updateSingleRootContext(projectPath, observations, options);
	}

	const { maxDepth, filename } = options;

	// Collect all file paths from observations
	const allFiles: string[] = [];
	for (const obs of observations) {
		for (const f of obs.filesModified) allFiles.push(f);
		for (const f of obs.filesRead) allFiles.push(f);
	}

	// Extract unique folder paths, filtering out invalid ones
	const folderPaths = extractFolderPaths(allFiles, projectPath, maxDepth);
	if (folderPaths.size === 0) return;

	// Group observations by folder
	const folderObservations = groupObservationsByFolder(observations, folderPaths, projectPath);

	// Update AGENTS.md for each folder
	for (const [folderPath, folderObs] of folderObservations) {
		try {
			const contextBlock = generateFolderContext(folderPath, folderObs, projectPath);
			await updateAgentsMd(folderPath, contextBlock, filename);
		} catch (error) {
			// Fire-and-forget: never let AGENTS.md updates break anything
			console.error(`[open-mem] Failed to update AGENTS.md in ${folderPath}:`, error);
		}
	}
}

/**
 * Single-root mode: creates/updates ONE file at {projectPath}/{filename}
 * with all folder activity grouped by section headers.
 */
async function updateSingleRootContext(
	projectPath: string,
	observations: Observation[],
	options: FolderContextOptions,
): Promise<void> {
	const { maxDepth, filename } = options;

	const qualityObs = observations.filter(isHighQualityObservation);
	if (qualityObs.length === 0) return;

	const allFiles: string[] = [];
	for (const obs of qualityObs) {
		for (const f of obs.filesModified) allFiles.push(f);
		for (const f of obs.filesRead) allFiles.push(f);
	}

	const folderPaths = extractFolderPaths(allFiles, projectPath, maxDepth);
	const folderObservations = groupObservationsByFolder(qualityObs, folderPaths, projectPath);

	// Root-level obs aren't captured by extractFolderPaths (which skips project root)
	const rootObs = qualityObs.filter((obs) => {
		const files = [...obs.filesModified, ...obs.filesRead];
		return files.some((f) => {
			if (!f) return false;
			const absPath = isAbsolute(f) ? f : join(projectPath, f);
			const folder = resolve(dirname(absPath));
			return folder === resolve(projectPath);
		});
	});
	if (rootObs.length > 0) {
		folderObservations.set(resolve(projectPath), rootObs);
	}

	if (folderObservations.size === 0) return;

	const lines: string[] = [];
	lines.push("## Project Activity (auto-generated by open-mem)");
	lines.push("");

	const sortedFolders = [...folderObservations.entries()]
		.map(([folder, obs]) => ({
			relPath: relative(projectPath, folder) || ".",
			observations: obs,
		}))
		.sort((a, b) => a.relPath.localeCompare(b.relPath));

	for (const { relPath, observations: folderObs } of sortedFolders) {
		const filtered = folderObs
			.filter(isHighQualityObservation)
			.sort((a, b) => b.createdAt.localeCompare(a.createdAt))
			.slice(0, 10);

		if (filtered.length === 0) continue;

		lines.push(`### ${relPath}/`);
		lines.push("| ID | Type | Title | Date |");
		lines.push("|----|------|-------|------|");

		for (const obs of filtered) {
			const icon = TYPE_ICONS[obs.type] || "üìù";
			const date = obs.createdAt.split("T")[0];
			const safeTitle = obs.title.replace(/\|/g, "\\|");
			lines.push(`| ${obs.id} | ${icon} ${obs.type} | ${safeTitle} | ${date} |`);
		}

		// Collect unique concepts
		const allConcepts = new Set<string>();
		for (const obs of filtered) {
			for (const c of obs.concepts) {
				allConcepts.add(c);
			}
		}
		if (allConcepts.size > 0) {
			const conceptList = [...allConcepts].slice(0, 10).join(", ");
			lines.push("");
			lines.push(`**Key concepts:** ${conceptList}`);
		}

		// Collect decision summaries
		const decisions = filtered.filter((obs) => obs.type === "decision").map((obs) => obs.title);
		if (decisions.length > 0) {
			lines.push("");
			lines.push(`**Recent decisions:** ${decisions.slice(0, 5).join("; ")}`);
		}

		lines.push("");
	}

	lines.push(
		"üí° *Use `mem-find` to search full details. Use `mem-create` to save important decisions.*",
	);

	const contextBlock = lines.join("\n");
	await updateAgentsMd(projectPath, contextBlock, filename);
}

// -----------------------------------------------------------------------------
// Context Generation
// -----------------------------------------------------------------------------

/**
 * Quality filter: excludes noise observations like "bash execution", "read execution".
 * Matches titles like "[word] execution" or "[word-word] execution".
 */
export function isHighQualityObservation(obs: Observation): boolean {
	return !/^\w[\w-]*\s+execution$/i.test(obs.title);
}

/**
 * Generate a markdown context block for a folder's recent activity.
 *
 * @param folderPath - Absolute path to the folder
 * @param observations - Observations relevant to this folder
 * @param projectPath - Absolute path to the project root
 * @returns Markdown string for the managed section
 */
export function generateFolderContext(
	folderPath: string,
	observations: Observation[],
	projectPath: string,
): string {
	const recent = [...observations]
		.filter(isHighQualityObservation)
		.sort((a, b) => b.createdAt.localeCompare(a.createdAt))
		.slice(0, 10);

	const relFolder = relative(projectPath, folderPath) || ".";
	const lines: string[] = [];

	lines.push(`## Recent Activity in \`${relFolder}/\` (auto-generated by open-mem)`);
	lines.push("");
	lines.push("| ID | Type | Title | Date |");
	lines.push("|----|------|-------|------|");

	for (const obs of recent) {
		const icon = TYPE_ICONS[obs.type] || "üìù";
		const date = obs.createdAt.split("T")[0];
		// Escape pipe characters in title
		const safeTitle = obs.title.replace(/\|/g, "\\|");
		lines.push(`| ${obs.id} | ${icon} ${obs.type} | ${safeTitle} | ${date} |`);
	}

	// Collect unique concepts
	const allConcepts = new Set<string>();
	for (const obs of recent) {
		for (const c of obs.concepts) {
			allConcepts.add(c);
		}
	}

	if (allConcepts.size > 0) {
		const conceptList = [...allConcepts].slice(0, 10).join(", ");
		lines.push("");
		lines.push(`**Key concepts:** ${conceptList}`);
	}

	// Collect decision summaries
	const decisions = recent.filter((obs) => obs.type === "decision").map((obs) => obs.title);

	if (decisions.length > 0) {
		lines.push("");
		lines.push(`**Recent decisions:** ${decisions.slice(0, 5).join("; ")}`);
	}

	// Decision narratives (1-line summaries for decisions)
	const decisionDetails = recent
		.filter((obs) => obs.type === "decision" && obs.narrative)
		.slice(0, 3);

	if (decisionDetails.length > 0) {
		lines.push("");
		lines.push("**Decision details:**");
		for (const obs of decisionDetails) {
			// Take first sentence or first 120 chars
			const summary = obs.narrative.split(/[.!?]\s/)[0];
			const truncated = summary.length > 120 ? `${summary.slice(0, 117)}...` : summary;
			lines.push(`- ‚öñÔ∏è ${obs.title}: ${truncated}`);
		}
	}

	lines.push("");
	lines.push(
		"üí° *Use `mem-find` to search full details across all sessions. Use `mem-create` to save important decisions.*",
	);

	return lines.join("\n");
}

// -----------------------------------------------------------------------------
// AGENTS.md File Management
// -----------------------------------------------------------------------------

/**
 * Update the managed section of an AGENTS.md file in the given folder.
 *
 * - Reads existing AGENTS.md if present
 * - Replaces content between managed tags (or appends if no tags exist)
 * - Preserves user content outside the tags
 * - Writes atomically via temp file + rename
 *
 * @param folderPath - Absolute path to the folder (must exist)
 * @param contextBlock - New content for the managed section
 */
export async function updateAgentsMd(
	folderPath: string,
	contextBlock: string,
	filename: string,
): Promise<void> {
	if (!existsSync(folderPath)) return;

	// Serialize concurrent writes to the same folder
	const previousLock = folderLocks.get(folderPath) ?? Promise.resolve();
	const currentOp = previousLock.then(async () => {
		const agentsMdPath = join(folderPath, filename);
		const tempPath = join(folderPath, `.${filename}.tmp`);

		let existingContent = "";
		try {
			existingContent = await readFile(agentsMdPath, "utf-8");
		} catch {
			// File doesn't exist yet
		}

		const finalContent = replaceTaggedContent(existingContent, contextBlock);

		try {
			await mkdir(dirname(tempPath), { recursive: true });
			await writeFile(tempPath, finalContent, "utf-8");
			await rename(tempPath, agentsMdPath);
		} catch (error) {
			try {
				await unlink(tempPath);
			} catch {
				// Temp file already gone
			}
			throw error;
		}
	});

	folderLocks.set(
		folderPath,
		currentOp.catch(() => {}),
	);
	return currentOp;
}

/**
 * Replace content between managed tags, preserving everything else.
 *
 * Three cases:
 * 1. No existing content ‚Üí wrap new content in tags
 * 2. Has existing tags ‚Üí replace only tagged section
 * 3. No tags in existing content ‚Üí append tagged content at end
 */
export function replaceTaggedContent(existingContent: string, newContent: string): string {
	// Case 1: No existing content
	if (!existingContent) {
		return `${START_TAG}\n${newContent}\n${END_TAG}\n`;
	}

	const startIdx = existingContent.indexOf(START_TAG);
	const endIdx = existingContent.indexOf(END_TAG);

	// Case 2: Has existing tags ‚Äî replace only tagged section
	if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
		const before = existingContent.substring(0, startIdx);
		const after = existingContent.substring(endIdx + END_TAG.length);
		return `${before}${START_TAG}\n${newContent}\n${END_TAG}${after}`;
	}

	// Corrupted tags: strip orphaned/reversed tags, then fall through to Case 3
	let cleaned = existingContent;
	if (startIdx !== -1 && endIdx === -1) {
		cleaned = cleaned.replace(START_TAG, "").trim();
	} else if (startIdx === -1 && endIdx !== -1) {
		cleaned = cleaned.replace(END_TAG, "").trim();
	} else if (startIdx !== -1 && endIdx !== -1 && endIdx <= startIdx) {
		cleaned = cleaned.replace(END_TAG, "").replace(START_TAG, "").trim();
	}

	// Case 3: No (valid) tags ‚Äî append at end
	return `${cleaned}\n\n${START_TAG}\n${newContent}\n${END_TAG}\n`;
}

// -----------------------------------------------------------------------------
// Path Helpers
// -----------------------------------------------------------------------------

/**
 * Extract unique, valid folder paths from file paths.
 *
 * Filters out:
 * - Project root itself
 * - Excluded directories (node_modules, .git, etc.)
 * - Folders deeper than maxDepth
 * - Non-existent folders
 * - Paths outside the project
 */
function extractFolderPaths(
	filePaths: string[],
	projectPath: string,
	maxDepth: number,
): Set<string> {
	const folders = new Set<string>();
	const normalizedRoot = resolve(projectPath);

	for (const filePath of filePaths) {
		if (!filePath || !filePath.trim()) continue;

		// Reject URLs and tilde paths
		if (filePath.startsWith("~") || filePath.startsWith("http")) continue;

		// Resolve to absolute path
		const absolutePath = isAbsolute(filePath) ? filePath : join(projectPath, filePath);
		const folderPath = dirname(absolutePath);
		const normalizedFolder = resolve(folderPath);

		// Must be within project
		if (!normalizedFolder.startsWith(normalizedRoot + sep) && normalizedFolder !== normalizedRoot) {
			continue;
		}

		// Skip project root
		if (normalizedFolder === normalizedRoot) continue;

		// Check depth
		const relPath = relative(normalizedRoot, normalizedFolder);
		const depth = relPath.split(sep).length;
		if (depth > maxDepth) continue;

		// Check for excluded directory segments
		const segments = normalize(relPath).split(sep);
		if (segments.some((s) => EXCLUDED_DIRS.has(s))) continue;

		// Must exist on disk
		if (!existsSync(normalizedFolder)) continue;

		folders.add(normalizedFolder);
	}

	return folders;
}

/**
 * Group observations by which folders they reference.
 * An observation can appear in multiple folders if it references files in different directories.
 */
function groupObservationsByFolder(
	observations: Observation[],
	folderPaths: Set<string>,
	projectPath: string,
): Map<string, Observation[]> {
	const groups = new Map<string, Observation[]>();

	for (const obs of observations) {
		const obsFiles = [...obs.filesModified, ...obs.filesRead];
		const obsFolders = new Set<string>();

		for (const filePath of obsFiles) {
			if (!filePath) continue;
			const absolutePath = isAbsolute(filePath) ? filePath : join(projectPath, filePath);
			const folderPath = resolve(dirname(absolutePath));

			if (folderPaths.has(folderPath)) {
				obsFolders.add(folderPath);
			}
		}

		for (const folder of obsFolders) {
			const list = groups.get(folder) ?? [];
			list.push(obs);
			groups.set(folder, list);
		}
	}

	return groups;
}
